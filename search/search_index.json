{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#auriclass-quick-estimation-of-candida-auris-clade-membership","title":"AuriClass: quick estimation of Candida auris clade membership","text":"<p>AuriClass is a small tool which predicts Candida auris clade based on Mash distances from reference genomes. It accepts fastq or fasta files. Analysis typically takes a minute for Fastq data and a couple of seconds for Fasta data.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install the tool using mamba and run an analysis on only the forward reads:</p> <pre><code>mamba create -n env_auriclass -c bioconda -c conda-forge auriclass\nconda activate env_auriclass\nauriclass -o output_report.tsv Candida_auris_R1.fq.gz\n</code></pre>"},{"location":"#motivation","title":"Motivation","text":"<p>We needed a tool that:</p> <ul> <li>quickly and accurately predicts C. auris clade from Illumina fastq and from fasta data</li> <li>could be used on a single sample in an automated workflow</li> </ul> <p>If you have fasta data, also check out the cauris_cladetyper task from TheiaEuk workflow.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#054-2023-10-27","title":"0.5.4 (2023-10-27)","text":""},{"location":"changelog/#documentation","title":"Documentation","text":"<ul> <li>add reference genome table (ad801da)</li> <li>fix typo in README (082b018)</li> <li>test mkdocs deployment (0441eb3)</li> </ul>"},{"location":"changelog/#053-2023-10-25","title":"0.5.3 (2023-10-25)","text":""},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>fix default data location (73f6e02)</li> </ul>"},{"location":"changelog/#052-2023-10-23","title":"0.5.2 (2023-10-23)","text":""},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>add missing types (bd250df)</li> </ul>"},{"location":"changelog/#documentation_1","title":"Documentation","text":"<ul> <li>update installation (7ab7c25)</li> </ul>"},{"location":"changelog/#051-2023-10-21","title":"0.5.1 (2023-10-21)","text":""},{"location":"changelog/#miscellaneous-chores","title":"Miscellaneous Chores","text":"<ul> <li>release 0.5.1 (92f944c)</li> </ul>"},{"location":"changelog/#050-2023-10-21","title":"0.5.0 (2023-10-21)","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>add possibility to skip extended qc (b8fff2d)</li> </ul>"},{"location":"changelog/#documentation_2","title":"Documentation","text":"<ul> <li>explain how to run parallel (af44653)</li> <li>update README (102be6f)</li> </ul>"},{"location":"changelog/#040-2023-10-20","title":"0.4.0 (2023-10-20)","text":""},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>add genome size calc for fasta input (25cd78f)</li> <li>allow fasta input (7fc5555)</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>no warn if same clade is within error bound (093371e)</li> <li>replace hardcoded value (8cfdb7e)</li> <li>typo in ref data (af74bb9)</li> </ul>"},{"location":"changelog/#032-2023-10-20","title":"0.3.2 (2023-10-20)","text":""},{"location":"changelog/#documentation_3","title":"Documentation","text":"<ul> <li>add info to README (b13d2b5)</li> </ul>"},{"location":"changelog/#031-2023-10-20","title":"0.3.1 (2023-10-20)","text":""},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>fill empty strings with dash symbol in report (9045f4a)</li> </ul>"},{"location":"changelog/#030-2023-10-19","title":"0.3.0 (2023-10-19)","text":""},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>expand reference (c2ce051)</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>set correct attr name (306fbbc)</li> <li>type issue when setting genome size from cli (5a45b24)</li> </ul>"},{"location":"changelog/#documentation_4","title":"Documentation","text":"<ul> <li>add docstrings (cb3fe6a)</li> <li>add to README (2472d53)</li> </ul>"},{"location":"changelog/#020-2023-10-18","title":"0.2.0 (2023-10-18)","text":""},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>add input/arg validation (9467b43)</li> </ul>"},{"location":"changelog/#010-2023-10-17","title":"0.1.0 (2023-10-17)","text":""},{"location":"changelog/#dependencies","title":"Dependencies","text":"<ul> <li>add conda env file (cd8116e)</li> <li>add conda env name (f05faea)</li> </ul>"},{"location":"changelog/#documentation_5","title":"Documentation","text":"<ul> <li>this is experimental software (8148c21)</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<ul> <li>I get the error <code>Input file {file_path} is not a fastq or fasta file</code>. How do I solve this?</li> </ul> <p>This happens when the <code>pyfastx</code> library cannot parse the input file(s) as Fastq or Fasta. Please check whether the files are correctly formatted and not corrupted. Plain and gzipped Fastq or Fasta files should work fine, other compression algorithms might not be supported. Check pyfastx docs for more information.</p> <ul> <li>I get the error <code>Mash is not installed</code>. How do I solve this?</li> </ul> <p>AuriClass relies on the availability of a Mash executable. Dependencies like mash and pyfastx can e.g. be installed through mamba/conda.</p> <ul> <li>I expect that my sample is C. auris, but my test sample returns a FAIL message in the output report for the species check. How can I force AuriClass to run the full analysis anyway?</li> </ul> <p>You can force AuriClass to run the whole analysis always by changing the QC thresholds, e.g. setting <code>--non_candida_threshold 1</code>. Use with caution, as an important QC step is disabled this way.</p> <ul> <li>I get a warning stating \"WARN: distance {distance} to closest sample is above threshold\". What does this mean?</li> </ul> <p>If the lowest distance observed is above the threshold controlled by <code>--high_distance_threshold</code> (default 0.003), a warning is emitted. This might mean a couple of different things, listed below. But first, it is important to realise that with assembled fasta input all samples will typically have lower distances to reference genomes than with fastq input, especially if the genomes are closely related. The relative differences remain, although absolute thresholds, like the one set by <code>--high_distance_threshold</code> could be lower for fasta input. Additionally, only supplying Illumina forward reads will show lower mash distances compared to supplying both forward and reverse reads.</p> <p>With that in mind, the warning can mean the following: 1. Your sample is part of a new clade. It seems to be part of C. auris, but the distance from any known clade is relatively high. This would usually only be picked up for Illumina forward and reverse read inputs. 2. Your data (probably the reverse reads) are noisy.</p> <p>In both cases, a comparative method with higher resolution (e.g. reference-based mapping phylogeny) would help solve what's wrong.</p> <ul> <li>I see \"SKIPPED\" in the output report for QC columns. What does this mean?</li> </ul> <p>If the sample fails the <code>qc_species</code> check (mash distance &gt; <code>--non_candida_threshold</code>), the sample is assumed to be a species not related to Candida. Therefore, no further analysis is performed and the output report is immediately returned.</p> <p>\"SKIPPED\" will also appear for QC_genome_size, QC_multiple_hits and QC_high_distance if you disable these check using <code>--no_qc</code>.</p> <ul> <li>I want to build my own database and use this for this tool. How do I start?</li> </ul> <p>You would need to select reference genomes and define their respective clades. A sketch of the reference genomes should be supplied to AuriClass using the <code>-r</code> flag, while a CSV file following the format of <code>data/clade_config.csv</code> should be supplied using the <code>-c</code> flag. Any related species which should be excluded from the analysis should be defined as \"outgroup\" in the clade configuration file.</p> <p>Warning</p> <p>Before using a new databases, you have to calibrate the thresholds and settings you're planning to use. In the calibration of the default dataset, it was clear that for example the minimal kmer coverage (<code>-m</code> in both AuriClass and Mash sketch) has a big influence on the exact value of mash distance. Other factors that should be considered are kmer size (<code>-k</code>) and sketch size (<code>-s</code>).</p> <p>If you're missing certain reference genomes or if new clades need to be added, you can also open an issue on GitHub.</p>"},{"location":"full_usage/","title":"Full usage","text":"<pre><code>usage: auriclass [-h] [-n NAME] [-o OUTPUT_REPORT_PATH] [--fastq] [--fasta] [--no_qc]\n[--log_file_path LOG_FILE_PATH] [--verbose] [--debug] [--version]\n[--expected_genome_size EXPECTED_GENOME_SIZE EXPECTED_GENOME_SIZE]\n[--non_candida_threshold NON_CANDIDA_THRESHOLD]\n[--high_dist_threshold HIGH_DIST_THRESHOLD] [-r REFERENCE_SKETCH_PATH]\n[-c CLADE_CONFIG_PATH] [-k KMER_SIZE] [-s SKETCH_SIZE]\n[-m MINIMAL_KMER_COVERAGE]\nread_file_paths [read_file_paths ...]\nAuriClass predicts Candida auris clade from Illumina WGS data\n\noptions:\n  -h, --help            show this help message and exit\nREQUIRED:\n  read_file_paths       Paths to read files\n\nMain arguments:\n  -n NAME, --name NAME  Name of isolate (default: isolate)\n-o OUTPUT_REPORT_PATH, --output_report_path OUTPUT_REPORT_PATH\n                        Path to output report (default: report.tsv)\n--fastq               Input files are fastq files (default: False)\n--fasta               Input files are fasta files (default: False)\n--no_qc               Skip extended QC (default: False)\n--log_file_path LOG_FILE_PATH\n                        Path to log file (default: None)\n--verbose             Verbose output (default: False)\n--debug               Very verbose output (default: False)\n--version             show program's version number and exit\nQC arguments:\n  --expected_genome_size EXPECTED_GENOME_SIZE EXPECTED_GENOME_SIZE\n                        Expected genome size range. Defaults 11.4-14.6 Mb are based on 150\nNCBI genomes and take mash genome size overestimation into\n                        account. (default: [11400000, 14900000])\n--non_candida_threshold NON_CANDIDA_THRESHOLD\n                        If the minimal distance from a reference sample is above this\n                        threshold, the sample might not be a Candida sp. (default: 0.01)\n--high_dist_threshold HIGH_DIST_THRESHOLD\n                        If the minimal distance from a reference sample is above this\n                        threshold, a warning is emitted. See the docs for more info.\n                        (default: 0.003)\nOther arguments\nNOTE: Only change these settings if you are doing something special.\nNOTE: This will require rebuilding the reference sketch and recalibration of thresholds!:\n  -r REFERENCE_SKETCH_PATH, --reference_sketch_path REFERENCE_SKETCH_PATH\n                        Path to reference sketch (default: )\n-c CLADE_CONFIG_PATH, --clade_config_path CLADE_CONFIG_PATH\n                        Path to clade config (default: )\n-k KMER_SIZE, --kmer_size KMER_SIZE\n                        Kmer size (default: 27)\n-s SKETCH_SIZE, --sketch_size SKETCH_SIZE\n                        Sketch size (default: 50000)\n-m MINIMAL_KMER_COVERAGE, --minimal_kmer_coverage MINIMAL_KMER_COVERAGE\n                        Minimal kmer coverage (default: 3)\n</code></pre>"},{"location":"input_output/","title":"Input &amp; output","text":""},{"location":"input_output/#input","title":"Input","text":"<p>AuriClass takes an arbitrary number of Fastq or Fasta files as input (however not Fastq and Fasta in a single analysis). AuriClass assumes all files originate from a single sample.</p>"},{"location":"input_output/#reference-data-included","title":"Reference data (included)","text":"<p>Two files with reference data are needed to start the analysis. Default files are included:</p> File Description <code>data/clade_config.csv</code> CSV table listing two columns: filename and associated clade. All included species that are not Candida auris are listed as \"outgroup\". <code>data/Candida_auris_clade_references.msh</code> Mash sketch of reference genomes of Candida auris and related species. <p>See Reference genomes for more information on the default database and see the FAQ for how to build your own database or change calibrated settings.</p>"},{"location":"input_output/#output","title":"Output","text":"<p>AuriClass outputs a tab-separated text file containing the main output, and a log file which save info written to STDERR.</p> <p>The columns in the output report have the following information:</p> Column Description Sample Sample name. Default value is \"isolate\". Clade Predicted clade. If the closest sample is not Candida auris, this field will contain \"not Candida auris\". Mash_distance_from_closest_reference Mash distance from the closest reference genome. QC_decision \"FAIL\" is QC_species is \"FAIL\". \"WARN\" if any other QC step indicates \"WARN\". Otherwise \"PASS\". QC_species \"FAIL\" if the mash distance from the closest reference is more than <code>--non_candida_threshold</code>. This indicates that the sample is not closely related to any Candida spp. QC_other_Candida \"WARN\" if the closest reference genome is not a Candida auris reference genome. This indicates that the sample is closer to another species than Candida auris. QC_genome_size \"WARN\" if the estimated genome size is outside the specified range. This is probably not accurate in case you run a diploid sample. QC_multiple_hits \"WARN\" if at least one sample is within the 99% Mash error bounds of the closest hit (from <code>mash bounds -k [KMERSIZE] -p 0.99</code>). This should not happen if the appropriate settings and database are used. QC_possible_new_clade \"WARN\" if the closest reference genome is Candida auris, but the Mash distance is higher than the <code>--new_clade_threshold</code>."},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#conda","title":"Conda","text":"<p>The easiest way to install AuriClass is through mamba/conda:</p> <pre><code>mamba create -n env_auriclass -c bioconda -c conda-forge auriclass\nconda activate env_auriclass\n</code></pre>"},{"location":"installation/#containers","title":"Containers","text":"<p>Alternatively, biocontainers has built a container from the AuriClass bioconda package. This container can be used with different container software, e.g. Singularity:</p> <pre><code>singularity pull docker://quay.io/biocontainers/auriclass:0.5.3--pyhdfd78af_0\n</code></pre> <p>Note</p> <p><code>auriclass:latest</code> is not defined in biocontainers, so make sure to specify the latest bioconda version and build.</p>"},{"location":"methodology/","title":"Methodology","text":"<p>Under the hood, AuriClass conceptually works as follows:</p> <pre><code>flowchart TD\n  A[Argument parsing &amp; input validation] --&gt;|FastA data| B_fa[Create FastaAuriclass object];\n  A --&gt; |FastQ data| B_fq[Create FastqAuriclass object];\n  B_fa --&gt; C_fa[Sketch input FastA];\n  B_fq --&gt; C_fq[Sketch input FastQ];\n  C_fa --&gt; D[Run mash dist &amp; select closest sample];\n  C_fq --&gt; D;\n  D --&gt; genome_size[\"Check whether genome size\n                    is within expected range\"];\n  D --&gt; E[Check if sample is close enough to any reference sample];\n  E --&gt; |Too distant| F_fail[\"FAIL: not Candida auris\n                                Further QC skipped\"];\n  E --&gt; |Close enough| F[Check is sample is closest to C. auris];\n  F --&gt; |Too distant| G_fail[WARN: other Candida/CUG-Ser1 clade sp.];\n  F --&gt; |Close enough| G[Select closest clade];\n  G --&gt; H[Final quality checks];\n  G --&gt; output\n  H --&gt; output\n\n  genome_size --&gt; output[Output]\n  F_fail --&gt; output\n  G_fail --&gt; output</code></pre> <p>Note</p> <p>Whether input files are FastQ or FastA is guessed by default based on <code>pyfastx</code> parsing. This can be overridden by specifying <code>--fastq</code> or <code>--fasta</code>.</p> <p>Steps that differ between FastQ and FastA data:</p> <ul> <li>Sketching is performed differently: filtering for minimal kmer coverage is required for FastQ.</li> <li>Genome size is estimated for FastQ using <code>mash sketch</code>, and parsed from FastA using <code>pyfastx</code></li> </ul> <p><code>FastqAuriclass</code> and <code>FastaAuriclass</code> classes are based on <code>BasicAuriclass</code> which handles most of the attribute setting. The specific classes define some format-specific methods and how all methods should be called by the <code>run()</code> method. </p>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#the-basicauriclass-class","title":"The <code>BasicAuriclass</code> class","text":"Source code in <code>auriclass/classes.py</code> <pre><code>class BasicAuriclass:\ndef __init__(\nself,\nname: str,\noutput_report_path: Path,\nread_paths: List[Path],\nreference_sketch_path: Path,\nkmer_size: int,\nsketch_size: int,\nminimal_kmer_coverage: int,\nclade_config_path: Path,\ngenome_size_range: List[int],\nnon_candida_threshold: float,\nhigh_dist_threshold: float,\nno_qc: bool,\n) -&gt; None:\nself.name: str = name\nself.output_report_path: Path = output_report_path\nself.read_paths: List[Path] = read_paths\nself.reference_sketch_path: Path = reference_sketch_path\nself.kmer_size: int = kmer_size\nself.sketch_size: int = sketch_size\nself.minimal_kmer_coverage: int = minimal_kmer_coverage\n# self.probability is used for mash bounds\n# this is not exposed in the CLI, because this should typically not be changed without extensive testing.\nself.probability: float = 0.99\nself.clade_dict: Dict[Hashable, Any] = pd.read_csv(\nclade_config_path,\nindex_col=0,\ndtype=str,\n).to_dict(orient=\"dict\")\nself.genome_size_range: List[int] = genome_size_range\nself.non_candida_threshold: float = non_candida_threshold\nself.high_dist_threshold: float = high_dist_threshold\nself.no_qc: bool = no_qc\nself.qc_decision: str = \"\"\nself.qc_genome_size: str = \"\"\nself.qc_other_candida: str = \"\"\nself.qc_species: str = \"\"\nself.qc_multiple_hits: str = \"\"\nself.qc_high_distance: str = \"\"\nself.query_sketch_path: Path = Path()\nself.estimated_genome_size: float = float()\nself.minimal_distance: float = float()\nself.clade: str = \"\"\nself.samples_within_error_bound: int = int()\nself.error_bound: float = float()\nself.stdout: str = \"\"\nself.stderr: str = \"\"\nself.mash_output: pd.DataFrame = pd.DataFrame()\nself.distances: List[float] = [float()]\ndef run_mash_dist(self) -&gt; pd.DataFrame:\n\"\"\"\n        Run Mash dist and save results.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        pandas.DataFrame\n            A DataFrame containing the results of the Mash dist, including the reference and query sequences,\n            the distance between them, the p-value, the number of matching hashes, and the predicted clade.\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n        The function uses the following attributes of the object:\n        - reference_sketch_path: the path to the reference sketch\n        - query_sketch_path: the path to the query sketch\n        - clade_dict: a dictionary containing the clade information for each reference sample\n        \"\"\"\ncommand = [\n\"mash\",\n\"dist\",\nself.reference_sketch_path,\nself.query_sketch_path,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash dist\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\n# Append stdout and stderr to object\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash dist\", line))\n# Read output into pandas dataframe\ndf = pd.read_csv(\nStringIO(output.stdout.decode(\"utf-8\")),\nsep=\"\\t\",\nheader=None,\nnames=[\"Reference\", \"Query\", \"Distance\", \"P-value\", \"Matching-hashes\"],\n)\ndf[\"Clade\"] = df[\"Reference\"].map(self.clade_dict[\"clade\"])\nself.mash_output = df\nreturn df\ndef check_genome_size(self) -&gt; None:\n\"\"\"\n        Compare the estimated genome size with the expected genome size range.\n        If the estimated genome size is outside the expected range, a warning message is logged and the\n        `qc_genome_size` attribute is set to \"WARN: genome size outside expected range\".\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - qc_genome_size: a warning message if the estimated genome size is outside the expected range\n        The function uses the following attributes of the object:\n        - estimated_genome_size: the estimated genome size of the current sample\n        \"\"\"\nif (\nself.estimated_genome_size &lt; self.genome_size_range[0]\nor self.estimated_genome_size &gt; self.genome_size_range[1]\n):\nlogging.warning(\nf\"AuriClass estimated genome size of {self.estimated_genome_size} is outside the expected range of {self.genome_size_range}\"\n)\nself.qc_genome_size = \"WARN: genome size outside expected range\"\ndef select_clade(self) -&gt; None:\n\"\"\"\n        Selects the closest reference sample and corresponding clade.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - closest_sample: the closest reference sample to the current test sample\n        - clade: the clade of the closest reference sample\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        The function uses the following attributes of the object:\n        - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n        - clade_dict: a dictionary containing the clade information for each reference sample\n        \"\"\"\n# Get highest hit, by sorting on distance and selecting first hit\nself.closest_sample = self.mash_output.sort_values(\"Distance\").iloc[0][\n\"Reference\"\n]\n# Get clade of closest sample\nself.clade = self.mash_output.loc[\nself.mash_output[\"Reference\"] == self.closest_sample, \"Clade\"\n].values[0]\n# Get minimal distance using self.mash_output and closest sample\nself.minimal_distance = self.mash_output.loc[\nself.mash_output[\"Reference\"] == self.closest_sample, \"Distance\"\n].values[0]\ndef check_non_candida(self) -&gt; bool:\n\"\"\"\n        Check if the distance to the closest sample is higher than the non-Candida threshold.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        bool\n            True if the distance to the closest sample is lower than or equal to the non-Candida threshold, False otherwise.\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold\n        The function uses the following attributes of the object:\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        - non_candida_threshold: the threshold above which the distance to the closest sample is considered to be non-Candida\n        \"\"\"\nif self.minimal_distance &gt; self.non_candida_threshold:\nlogging.warning(\nf\"AuriClass found a distance of {self.minimal_distance} to the closest sample, please ensure this is Candida auris\"\n)\nself.qc_species = f\"FAIL: distance {self.minimal_distance} to closest sample is above threshold\"\nreturn False\nelse:\nreturn True\ndef check_for_outgroup(self) -&gt; bool:\n\"\"\"\n        Check if the closest sample is defined as outgroup.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        bool\n            True if the closest sample is not an outgroup, False otherwise.\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - qc_other_candida: a warning message if the closest sample is defined as outgroup\n        The function uses the following attributes of the object:\n        - clade: the clade of the closest reference sample\n        - closest_sample: the closest reference sample to the current test sample\n        \"\"\"\nif self.clade == \"outgroup\":\nlogging.warning(\nf\"AuriClass found a non-Candida auris reference as closest sample, please ensure this is Candida auris\"\n)\nself.qc_other_candida = (\nf\"FAIL: outgroup reference {self.closest_sample} as closest sample\"\n)\nreturn False\nelse:\nreturn True\ndef check_high_dist(self) -&gt; None:\n\"\"\"\n        Check if the closest sample is above high_dist_threshold distance. If it is, it may indicate a new clade.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance\n        The function uses the following attributes of the object:\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        - high_dist_threshold: the threshold above which the distance to the closest sample is considered to be a new clade\n        \"\"\"\nif self.minimal_distance &gt; self.high_dist_threshold:\nlogging.warning(\nf\"AuriClass found a distance of {self.minimal_distance} to the closest sample, please ensure this is Candida auris\"\n)\nself.qc_high_distance = f\"WARN: distance {self.minimal_distance} to closest sample is above threshold\"\ndef get_error_bounds(self) -&gt; str:\n\"\"\"\n        Get error bounds for the current sketch size and kmer size.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        str\n            The STDOUT of the mash bounds command.\n        Notes\n        -----\n        The function uses the following attributes of the object:\n        - kmer_size: the kmer size to use for the sketch\n        - probability: the probability to use for the mash bounds command\n        \"\"\"\ncommand = [\n\"mash\",\n\"bounds\",\n\"-k\",\nstr(self.kmer_size),\n\"-p\",\nstr(self.probability),\n]\nlogging.info(add_tag(\"mash bounds\", \" \".join(command)))\noutput = subprocess.run(\ncommand,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash bounds\", line))\nreturn output.stdout.decode(\"utf-8\")\ndef process_error_bounds(self, error_bounds_text: str) -&gt; None:\n\"\"\"\n        Process the error bounds text to get the error bound for the current sketch size and kmer size.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        error_bounds_text : str\n            The STDOUT of the mash bounds command.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - error_bound: the error bound for the current sketch size and kmer size\n        The function uses the following attributes of the object:\n        - sketch_size: the size of the sketch to create\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        \"\"\"\n# Split text into lines\nlines = error_bounds_text.splitlines()\n# Find line with \"Mash distance\"\nfor i, line in enumerate(lines):\nif \"Mash distance\" in line:\nstart_line = i + 1\nbreak\n# Find line with \"Screen distance\"\nfor i, line in enumerate(lines):\nif \"Screen distance\" in line:\nend_line = i\nbreak\n# Read lines into dataframe\ndf = pd.read_csv(\nStringIO(\"\\n\".join(lines[start_line:end_line])),\nsep=\"\\t\",\n)\n# Get first column of which column name is higher than min_dist\nfor col in df.columns[1:]:\nif float(col) &gt; self.minimal_distance:\nselected_col = str(col)\nbreak\nself.error_bound = df.loc[\ndf[\"Sketch\"] == self.sketch_size, selected_col\n].values[0]\ndef compare_with_error_bounds(self) -&gt; None:\n\"\"\"\n        Compare the distance between the current test sample and the closest reference sample with the error bound.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - distances: the distances between the current test sample and all other reference samples\n        - samples_within_error_bound: the number of samples within the error bound of the closest sample\n        - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0\n        The function uses the following attributes of the object:\n        - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n        - closest_sample: the closest reference sample to the current test sample\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        - error_bound: the error bound for the current sketch size and kmer size\n        \"\"\"\n# Get distance between highest hit and other samples\ndist_array = self.mash_output.loc[\nself.mash_output[\"Clade\"] != self.clade, \"Distance\"\n].values\nself.distances = [float(distance) for distance in dist_array]\n# Check if distance is higher than error_bound\ncount_above_threshold = 0\nfor distance in self.distances:\nif distance &lt; (self.minimal_distance + self.error_bound):\nlogging.debug(\nadd_tag(\n\"compare_with_error_bounds\",\nf\"distance {distance} is above threshold: ({self.minimal_distance} + {self.error_bound})\",\n)\n)\ncount_above_threshold += 1\nelse:\nlogging.debug(\nadd_tag(\n\"compare_with_error_bounds\",\nf\"distance {distance} is below threshold: ({self.minimal_distance} + {self.error_bound})\",\n)\n)\nself.samples_within_error_bound = count_above_threshold\n# If samples are found within error bound, warn user\nif self.samples_within_error_bound &gt; 0:\nlogging.warning(\nf\"AuriClass found {self.samples_within_error_bound} sample(s) within the error bound of {self.error_bound} of the closest sample\"\n)\nself.qc_multiple_hits = (\nf\"WARN: {self.samples_within_error_bound} sample(s) within error bound\"\n)\ndef save_report(self) -&gt; None:\n\"\"\"\n        Save the report to a TSV file.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - qc_decision: the QC decision based on the QC attributes\n        The function uses the following attributes of the object:\n        - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold\n        - qc_other_candida: a warning message if the closest sample is defined as outgroup\n        - qc_genome_size: a warning message if the estimated genome size is outside the expected range\n        - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0\n        - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance\n        - name: the name of the current test sample\n        - clade: the clade of the closest reference sample\n        - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n        - output_report_path: the path to the output report\n        - no_qc: a boolean indicating whether to skip extended QC\n        \"\"\"\nFAIL_metrics = [\n\"qc_species\",\n\"qc_other_candida\",\n]\nWARN_metrics = [\n\"qc_genome_size\",\n\"qc_multiple_hits\",\n\"qc_high_distance\",\n]\nif self.no_qc:\n# Set all attributes in WARN_metrics to \"SKIPPED\"\nfor metric in WARN_metrics:\nsetattr(self, metric, \"SKIPPED\")\n# Check if any of the qc attributes contain \"WARN\"\nFAIL_observed = any(\n[\"FAIL\" in getattr(self, qc_metric) for qc_metric in FAIL_metrics]\n)\nWARN_observed = any(\n[\"WARN\" in getattr(self, qc_metric) for qc_metric in WARN_metrics]\n)\nif FAIL_observed:\nself.qc_decision = \"FAIL\"\nelif WARN_observed:\nself.qc_decision = \"WARN\"\nelse:\nself.qc_decision = \"PASS\"\n# if any(\n#     [\n#         (\"FAIL\" in qc_metric) for qc_metric in [self.qc_species],\n#     ]\n# ):\n#     self.qc_decision = \"FAIL\"\n# elif any(\n#     [\n#         self.qc_genome_size,\n#         self.qc_other_candida,\n#         self.qc_multiple_hits,\n#         self.qc_high_distance,\n#     ]\n# ):\n#     self.qc_decision = \"WARN\"\n# else:\n#     self.qc_decision = \"PASS\"\npd.DataFrame(\n[\n[\nself.name,\nself.clade,\nself.minimal_distance,\nself.qc_decision,\nself.qc_species,\nself.qc_other_candida,\nself.qc_genome_size,\nself.qc_multiple_hits,\nself.qc_high_distance,\n]\n],\ncolumns=[\n\"Sample\",\n\"Clade\",\n\"Mash_distance_from_closest_reference\",\n\"QC_decision\",\n\"QC_species\",\n\"QC_other_Candida\",\n\"QC_genome_size\",\n\"QC_multiple_hits\",\n\"QC_high_distance\",\n],\n).replace(\"\", \"PASS\").to_csv(self.output_report_path, sep=\"\\t\", index=False)\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_for_outgroup","title":"<code>check_for_outgroup()</code>","text":"<p>Check if the closest sample is defined as outgroup.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_for_outgroup--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_for_outgroup--returns","title":"Returns","text":"<p>bool     True if the closest sample is not an outgroup, False otherwise.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_for_outgroup--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - qc_other_candida: a warning message if the closest sample is defined as outgroup</p> <p>The function uses the following attributes of the object: - clade: the clade of the closest reference sample - closest_sample: the closest reference sample to the current test sample</p> Source code in <code>auriclass/classes.py</code> <pre><code>def check_for_outgroup(self) -&gt; bool:\n\"\"\"\n    Check if the closest sample is defined as outgroup.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    bool\n        True if the closest sample is not an outgroup, False otherwise.\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - qc_other_candida: a warning message if the closest sample is defined as outgroup\n    The function uses the following attributes of the object:\n    - clade: the clade of the closest reference sample\n    - closest_sample: the closest reference sample to the current test sample\n    \"\"\"\nif self.clade == \"outgroup\":\nlogging.warning(\nf\"AuriClass found a non-Candida auris reference as closest sample, please ensure this is Candida auris\"\n)\nself.qc_other_candida = (\nf\"FAIL: outgroup reference {self.closest_sample} as closest sample\"\n)\nreturn False\nelse:\nreturn True\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_genome_size","title":"<code>check_genome_size()</code>","text":"<p>Compare the estimated genome size with the expected genome size range.</p> <p>If the estimated genome size is outside the expected range, a warning message is logged and the <code>qc_genome_size</code> attribute is set to \"WARN: genome size outside expected range\".</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_genome_size--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_genome_size--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_genome_size--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - qc_genome_size: a warning message if the estimated genome size is outside the expected range</p> <p>The function uses the following attributes of the object: - estimated_genome_size: the estimated genome size of the current sample</p> Source code in <code>auriclass/classes.py</code> <pre><code>def check_genome_size(self) -&gt; None:\n\"\"\"\n    Compare the estimated genome size with the expected genome size range.\n    If the estimated genome size is outside the expected range, a warning message is logged and the\n    `qc_genome_size` attribute is set to \"WARN: genome size outside expected range\".\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - qc_genome_size: a warning message if the estimated genome size is outside the expected range\n    The function uses the following attributes of the object:\n    - estimated_genome_size: the estimated genome size of the current sample\n    \"\"\"\nif (\nself.estimated_genome_size &lt; self.genome_size_range[0]\nor self.estimated_genome_size &gt; self.genome_size_range[1]\n):\nlogging.warning(\nf\"AuriClass estimated genome size of {self.estimated_genome_size} is outside the expected range of {self.genome_size_range}\"\n)\nself.qc_genome_size = \"WARN: genome size outside expected range\"\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_high_dist","title":"<code>check_high_dist()</code>","text":"<p>Check if the closest sample is above high_dist_threshold distance. If it is, it may indicate a new clade.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_high_dist--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_high_dist--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_high_dist--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance</p> <p>The function uses the following attributes of the object: - minimal_distance: the minimal distance between the current test sample and the closest reference sample - high_dist_threshold: the threshold above which the distance to the closest sample is considered to be a new clade</p> Source code in <code>auriclass/classes.py</code> <pre><code>def check_high_dist(self) -&gt; None:\n\"\"\"\n    Check if the closest sample is above high_dist_threshold distance. If it is, it may indicate a new clade.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance\n    The function uses the following attributes of the object:\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    - high_dist_threshold: the threshold above which the distance to the closest sample is considered to be a new clade\n    \"\"\"\nif self.minimal_distance &gt; self.high_dist_threshold:\nlogging.warning(\nf\"AuriClass found a distance of {self.minimal_distance} to the closest sample, please ensure this is Candida auris\"\n)\nself.qc_high_distance = f\"WARN: distance {self.minimal_distance} to closest sample is above threshold\"\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_non_candida","title":"<code>check_non_candida()</code>","text":"<p>Check if the distance to the closest sample is higher than the non-Candida threshold.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_non_candida--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_non_candida--returns","title":"Returns","text":"<p>bool     True if the distance to the closest sample is lower than or equal to the non-Candida threshold, False otherwise.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.check_non_candida--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold</p> <p>The function uses the following attributes of the object: - minimal_distance: the minimal distance between the current test sample and the closest reference sample - non_candida_threshold: the threshold above which the distance to the closest sample is considered to be non-Candida</p> Source code in <code>auriclass/classes.py</code> <pre><code>def check_non_candida(self) -&gt; bool:\n\"\"\"\n    Check if the distance to the closest sample is higher than the non-Candida threshold.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    bool\n        True if the distance to the closest sample is lower than or equal to the non-Candida threshold, False otherwise.\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold\n    The function uses the following attributes of the object:\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    - non_candida_threshold: the threshold above which the distance to the closest sample is considered to be non-Candida\n    \"\"\"\nif self.minimal_distance &gt; self.non_candida_threshold:\nlogging.warning(\nf\"AuriClass found a distance of {self.minimal_distance} to the closest sample, please ensure this is Candida auris\"\n)\nself.qc_species = f\"FAIL: distance {self.minimal_distance} to closest sample is above threshold\"\nreturn False\nelse:\nreturn True\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.compare_with_error_bounds","title":"<code>compare_with_error_bounds()</code>","text":"<p>Compare the distance between the current test sample and the closest reference sample with the error bound.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.compare_with_error_bounds--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.compare_with_error_bounds--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.compare_with_error_bounds--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - distances: the distances between the current test sample and all other reference samples - samples_within_error_bound: the number of samples within the error bound of the closest sample - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0</p> <p>The function uses the following attributes of the object: - mash_output: a pandas DataFrame containing the output of the Mash distance calculation - closest_sample: the closest reference sample to the current test sample - minimal_distance: the minimal distance between the current test sample and the closest reference sample - error_bound: the error bound for the current sketch size and kmer size</p> Source code in <code>auriclass/classes.py</code> <pre><code>def compare_with_error_bounds(self) -&gt; None:\n\"\"\"\n    Compare the distance between the current test sample and the closest reference sample with the error bound.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - distances: the distances between the current test sample and all other reference samples\n    - samples_within_error_bound: the number of samples within the error bound of the closest sample\n    - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0\n    The function uses the following attributes of the object:\n    - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n    - closest_sample: the closest reference sample to the current test sample\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    - error_bound: the error bound for the current sketch size and kmer size\n    \"\"\"\n# Get distance between highest hit and other samples\ndist_array = self.mash_output.loc[\nself.mash_output[\"Clade\"] != self.clade, \"Distance\"\n].values\nself.distances = [float(distance) for distance in dist_array]\n# Check if distance is higher than error_bound\ncount_above_threshold = 0\nfor distance in self.distances:\nif distance &lt; (self.minimal_distance + self.error_bound):\nlogging.debug(\nadd_tag(\n\"compare_with_error_bounds\",\nf\"distance {distance} is above threshold: ({self.minimal_distance} + {self.error_bound})\",\n)\n)\ncount_above_threshold += 1\nelse:\nlogging.debug(\nadd_tag(\n\"compare_with_error_bounds\",\nf\"distance {distance} is below threshold: ({self.minimal_distance} + {self.error_bound})\",\n)\n)\nself.samples_within_error_bound = count_above_threshold\n# If samples are found within error bound, warn user\nif self.samples_within_error_bound &gt; 0:\nlogging.warning(\nf\"AuriClass found {self.samples_within_error_bound} sample(s) within the error bound of {self.error_bound} of the closest sample\"\n)\nself.qc_multiple_hits = (\nf\"WARN: {self.samples_within_error_bound} sample(s) within error bound\"\n)\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.get_error_bounds","title":"<code>get_error_bounds()</code>","text":"<p>Get error bounds for the current sketch size and kmer size.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.get_error_bounds--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.get_error_bounds--returns","title":"Returns","text":"<p>str     The STDOUT of the mash bounds command.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.get_error_bounds--notes","title":"Notes","text":"<p>The function uses the following attributes of the object: - kmer_size: the kmer size to use for the sketch - probability: the probability to use for the mash bounds command</p> Source code in <code>auriclass/classes.py</code> <pre><code>def get_error_bounds(self) -&gt; str:\n\"\"\"\n    Get error bounds for the current sketch size and kmer size.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    str\n        The STDOUT of the mash bounds command.\n    Notes\n    -----\n    The function uses the following attributes of the object:\n    - kmer_size: the kmer size to use for the sketch\n    - probability: the probability to use for the mash bounds command\n    \"\"\"\ncommand = [\n\"mash\",\n\"bounds\",\n\"-k\",\nstr(self.kmer_size),\n\"-p\",\nstr(self.probability),\n]\nlogging.info(add_tag(\"mash bounds\", \" \".join(command)))\noutput = subprocess.run(\ncommand,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash bounds\", line))\nreturn output.stdout.decode(\"utf-8\")\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.process_error_bounds","title":"<code>process_error_bounds(error_bounds_text)</code>","text":"<p>Process the error bounds text to get the error bound for the current sketch size and kmer size.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.process_error_bounds--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object. error_bounds_text : str     The STDOUT of the mash bounds command.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.process_error_bounds--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.process_error_bounds--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - error_bound: the error bound for the current sketch size and kmer size</p> <p>The function uses the following attributes of the object: - sketch_size: the size of the sketch to create - minimal_distance: the minimal distance between the current test sample and the closest reference sample</p> Source code in <code>auriclass/classes.py</code> <pre><code>def process_error_bounds(self, error_bounds_text: str) -&gt; None:\n\"\"\"\n    Process the error bounds text to get the error bound for the current sketch size and kmer size.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    error_bounds_text : str\n        The STDOUT of the mash bounds command.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - error_bound: the error bound for the current sketch size and kmer size\n    The function uses the following attributes of the object:\n    - sketch_size: the size of the sketch to create\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    \"\"\"\n# Split text into lines\nlines = error_bounds_text.splitlines()\n# Find line with \"Mash distance\"\nfor i, line in enumerate(lines):\nif \"Mash distance\" in line:\nstart_line = i + 1\nbreak\n# Find line with \"Screen distance\"\nfor i, line in enumerate(lines):\nif \"Screen distance\" in line:\nend_line = i\nbreak\n# Read lines into dataframe\ndf = pd.read_csv(\nStringIO(\"\\n\".join(lines[start_line:end_line])),\nsep=\"\\t\",\n)\n# Get first column of which column name is higher than min_dist\nfor col in df.columns[1:]:\nif float(col) &gt; self.minimal_distance:\nselected_col = str(col)\nbreak\nself.error_bound = df.loc[\ndf[\"Sketch\"] == self.sketch_size, selected_col\n].values[0]\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.run_mash_dist","title":"<code>run_mash_dist()</code>","text":"<p>Run Mash dist and save results.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.run_mash_dist--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.run_mash_dist--returns","title":"Returns","text":"<p>pandas.DataFrame     A DataFrame containing the results of the Mash dist, including the reference and query sequences,     the distance between them, the p-value, the number of matching hashes, and the predicted clade.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.run_mash_dist--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - mash_output: a pandas DataFrame containing the output of the Mash distance calculation</p> <p>The function uses the following attributes of the object: - reference_sketch_path: the path to the reference sketch - query_sketch_path: the path to the query sketch - clade_dict: a dictionary containing the clade information for each reference sample</p> Source code in <code>auriclass/classes.py</code> <pre><code>def run_mash_dist(self) -&gt; pd.DataFrame:\n\"\"\"\n    Run Mash dist and save results.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    pandas.DataFrame\n        A DataFrame containing the results of the Mash dist, including the reference and query sequences,\n        the distance between them, the p-value, the number of matching hashes, and the predicted clade.\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n    The function uses the following attributes of the object:\n    - reference_sketch_path: the path to the reference sketch\n    - query_sketch_path: the path to the query sketch\n    - clade_dict: a dictionary containing the clade information for each reference sample\n    \"\"\"\ncommand = [\n\"mash\",\n\"dist\",\nself.reference_sketch_path,\nself.query_sketch_path,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash dist\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\n# Append stdout and stderr to object\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash dist\", line))\n# Read output into pandas dataframe\ndf = pd.read_csv(\nStringIO(output.stdout.decode(\"utf-8\")),\nsep=\"\\t\",\nheader=None,\nnames=[\"Reference\", \"Query\", \"Distance\", \"P-value\", \"Matching-hashes\"],\n)\ndf[\"Clade\"] = df[\"Reference\"].map(self.clade_dict[\"clade\"])\nself.mash_output = df\nreturn df\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.save_report","title":"<code>save_report()</code>","text":"<p>Save the report to a TSV file.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.save_report--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.save_report--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.save_report--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - qc_decision: the QC decision based on the QC attributes</p> <p>The function uses the following attributes of the object: - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold - qc_other_candida: a warning message if the closest sample is defined as outgroup - qc_genome_size: a warning message if the estimated genome size is outside the expected range - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0 - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance - name: the name of the current test sample - clade: the clade of the closest reference sample - minimal_distance: the minimal distance between the current test sample and the closest reference sample - output_report_path: the path to the output report - no_qc: a boolean indicating whether to skip extended QC</p> Source code in <code>auriclass/classes.py</code> <pre><code>def save_report(self) -&gt; None:\n\"\"\"\n    Save the report to a TSV file.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - qc_decision: the QC decision based on the QC attributes\n    The function uses the following attributes of the object:\n    - qc_species: a warning message if the distance to the closest sample is higher than the non-Candida threshold\n    - qc_other_candida: a warning message if the closest sample is defined as outgroup\n    - qc_genome_size: a warning message if the estimated genome size is outside the expected range\n    - qc_multiple_hits: a warning message if the number of samples within the error bound of the closest sample is higher than 0\n    - qc_high_distance: a warning message if the closest sample is above self.high_dist_threshold distance\n    - name: the name of the current test sample\n    - clade: the clade of the closest reference sample\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    - output_report_path: the path to the output report\n    - no_qc: a boolean indicating whether to skip extended QC\n    \"\"\"\nFAIL_metrics = [\n\"qc_species\",\n\"qc_other_candida\",\n]\nWARN_metrics = [\n\"qc_genome_size\",\n\"qc_multiple_hits\",\n\"qc_high_distance\",\n]\nif self.no_qc:\n# Set all attributes in WARN_metrics to \"SKIPPED\"\nfor metric in WARN_metrics:\nsetattr(self, metric, \"SKIPPED\")\n# Check if any of the qc attributes contain \"WARN\"\nFAIL_observed = any(\n[\"FAIL\" in getattr(self, qc_metric) for qc_metric in FAIL_metrics]\n)\nWARN_observed = any(\n[\"WARN\" in getattr(self, qc_metric) for qc_metric in WARN_metrics]\n)\nif FAIL_observed:\nself.qc_decision = \"FAIL\"\nelif WARN_observed:\nself.qc_decision = \"WARN\"\nelse:\nself.qc_decision = \"PASS\"\n# if any(\n#     [\n#         (\"FAIL\" in qc_metric) for qc_metric in [self.qc_species],\n#     ]\n# ):\n#     self.qc_decision = \"FAIL\"\n# elif any(\n#     [\n#         self.qc_genome_size,\n#         self.qc_other_candida,\n#         self.qc_multiple_hits,\n#         self.qc_high_distance,\n#     ]\n# ):\n#     self.qc_decision = \"WARN\"\n# else:\n#     self.qc_decision = \"PASS\"\npd.DataFrame(\n[\n[\nself.name,\nself.clade,\nself.minimal_distance,\nself.qc_decision,\nself.qc_species,\nself.qc_other_candida,\nself.qc_genome_size,\nself.qc_multiple_hits,\nself.qc_high_distance,\n]\n],\ncolumns=[\n\"Sample\",\n\"Clade\",\n\"Mash_distance_from_closest_reference\",\n\"QC_decision\",\n\"QC_species\",\n\"QC_other_Candida\",\n\"QC_genome_size\",\n\"QC_multiple_hits\",\n\"QC_high_distance\",\n],\n).replace(\"\", \"PASS\").to_csv(self.output_report_path, sep=\"\\t\", index=False)\n</code></pre>"},{"location":"reference/#auriclass.classes.BasicAuriclass.select_clade","title":"<code>select_clade()</code>","text":"<p>Selects the closest reference sample and corresponding clade.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.select_clade--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.select_clade--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.BasicAuriclass.select_clade--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - closest_sample: the closest reference sample to the current test sample - clade: the clade of the closest reference sample - minimal_distance: the minimal distance between the current test sample and the closest reference sample</p> <p>The function uses the following attributes of the object: - mash_output: a pandas DataFrame containing the output of the Mash distance calculation - clade_dict: a dictionary containing the clade information for each reference sample</p> Source code in <code>auriclass/classes.py</code> <pre><code>def select_clade(self) -&gt; None:\n\"\"\"\n    Selects the closest reference sample and corresponding clade.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - closest_sample: the closest reference sample to the current test sample\n    - clade: the clade of the closest reference sample\n    - minimal_distance: the minimal distance between the current test sample and the closest reference sample\n    The function uses the following attributes of the object:\n    - mash_output: a pandas DataFrame containing the output of the Mash distance calculation\n    - clade_dict: a dictionary containing the clade information for each reference sample\n    \"\"\"\n# Get highest hit, by sorting on distance and selecting first hit\nself.closest_sample = self.mash_output.sort_values(\"Distance\").iloc[0][\n\"Reference\"\n]\n# Get clade of closest sample\nself.clade = self.mash_output.loc[\nself.mash_output[\"Reference\"] == self.closest_sample, \"Clade\"\n].values[0]\n# Get minimal distance using self.mash_output and closest sample\nself.minimal_distance = self.mash_output.loc[\nself.mash_output[\"Reference\"] == self.closest_sample, \"Distance\"\n].values[0]\n</code></pre>"},{"location":"reference/#the-fastqauriclass-class","title":"The <code>FastqAuriclass</code> class","text":"<p>             Bases: <code>BasicAuriclass</code></p> Source code in <code>auriclass/classes.py</code> <pre><code>class FastqAuriclass(BasicAuriclass):\ndef sketch_fastq_query(self) -&gt; None:\n\"\"\"\n        Sketches the query fastq files using mash.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Raises\n        ------\n        ValueError\n            If no sequence records are found in the specified fastq file(s).\n            If the estimated genome size cannot be parsed from the mash sketch STDERR.\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - stdout: the STDOUT of the mash sketch command\n        - estimated_genome_size: the estimated genome size of the current test sample\n        The function uses the following attributes of the object:\n        - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch\n        - query_sketch_path: the path to the query sketch\n        - kmer_size: the kmer size to use for the sketch\n        - sketch_size: the size of the sketch to create\n        - read_paths: the paths to the fastq files to sketch\n        \"\"\"\ncommand = [\n\"mash\",\n\"sketch\",\n\"-r\",\n\"-m\",\nstr(self.minimal_kmer_coverage),\n\"-o\",\nself.query_sketch_path,\n\"-k\",\nstr(self.kmer_size),\n\"-s\",\nstr(self.sketch_size),\n*self.read_paths,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash sketch\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif \"ERROR: Did not find fasta records in\" in output.stderr.decode(\"utf-8\"):\nraise ValueError(\nf\"Did not find sequence records in {self.read_paths}. Please check if these are valid fastq files\"\n)\n# Add stdout and stderr to object\nself.stdout = output.stdout.decode(\"utf-8\")\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash sketch\", line))\n# find line with \"Estimated genome size\" and get value\nfor line in stderr.splitlines():\nif \"Estimated genome size\" in line:\nself.estimated_genome_size = float(line.split()[-1])\nbreak\nelse:\nraise ValueError(\n\"Estimated genome size could not be parsed from mash sketch STDERR\"\n)\ndef run(self) -&gt; None:\n# Sketch query genome using tempfile\nwith tempfile.TemporaryDirectory() as tmpdir:\nself.query_sketch_path = Path(tmpdir).joinpath(\"tmpfile.msh\")\nself.sketch_fastq_query()\n# Run mash screen\nself.run_mash_dist()\n# Check if genome size is within expected range\nself.check_genome_size()\n# Process results\nself.select_clade()\n# Check if all samples not above certain threshold indicating other species\nprobably_candida = self.check_non_candida()\nif probably_candida:\n# Check if clade is not \"outgroup\"\nprobably_cauris = self.check_for_outgroup()\nif probably_cauris:\nif self.no_qc == False:\n# Check if closest sample is above self.high_dist_threshold distance --&gt; new clade?\nself.check_high_dist()\n# Check error bounds and check number of samples within error bounds\nerror_bounds_text = self.get_error_bounds()\nself.process_error_bounds(error_bounds_text)\nself.compare_with_error_bounds()\nelse:\nself.clade = \"other Candida/CUG-Ser1 clade sp.\"\nelse:\nself.clade = \"not Candida auris\"\nself.qc_other_candida = \"SKIPPED\"\nself.qc_genome_size = \"SKIPPED\"\nself.qc_multiple_hits = \"SKIPPED\"\nself.qc_high_distance = \"SKIPPED\"\n# Save report\nself.save_report()\n</code></pre>"},{"location":"reference/#auriclass.classes.FastqAuriclass.sketch_fastq_query","title":"<code>sketch_fastq_query()</code>","text":"<p>Sketches the query fastq files using mash.</p>"},{"location":"reference/#auriclass.classes.FastqAuriclass.sketch_fastq_query--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.FastqAuriclass.sketch_fastq_query--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.FastqAuriclass.sketch_fastq_query--raises","title":"Raises","text":"<p>ValueError     If no sequence records are found in the specified fastq file(s).</p> <pre><code>If the estimated genome size cannot be parsed from the mash sketch STDERR.\n</code></pre>"},{"location":"reference/#auriclass.classes.FastqAuriclass.sketch_fastq_query--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - stdout: the STDOUT of the mash sketch command - estimated_genome_size: the estimated genome size of the current test sample</p> <p>The function uses the following attributes of the object: - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch - query_sketch_path: the path to the query sketch - kmer_size: the kmer size to use for the sketch - sketch_size: the size of the sketch to create - read_paths: the paths to the fastq files to sketch</p> Source code in <code>auriclass/classes.py</code> <pre><code>def sketch_fastq_query(self) -&gt; None:\n\"\"\"\n    Sketches the query fastq files using mash.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    ValueError\n        If no sequence records are found in the specified fastq file(s).\n        If the estimated genome size cannot be parsed from the mash sketch STDERR.\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - stdout: the STDOUT of the mash sketch command\n    - estimated_genome_size: the estimated genome size of the current test sample\n    The function uses the following attributes of the object:\n    - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch\n    - query_sketch_path: the path to the query sketch\n    - kmer_size: the kmer size to use for the sketch\n    - sketch_size: the size of the sketch to create\n    - read_paths: the paths to the fastq files to sketch\n    \"\"\"\ncommand = [\n\"mash\",\n\"sketch\",\n\"-r\",\n\"-m\",\nstr(self.minimal_kmer_coverage),\n\"-o\",\nself.query_sketch_path,\n\"-k\",\nstr(self.kmer_size),\n\"-s\",\nstr(self.sketch_size),\n*self.read_paths,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash sketch\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif \"ERROR: Did not find fasta records in\" in output.stderr.decode(\"utf-8\"):\nraise ValueError(\nf\"Did not find sequence records in {self.read_paths}. Please check if these are valid fastq files\"\n)\n# Add stdout and stderr to object\nself.stdout = output.stdout.decode(\"utf-8\")\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash sketch\", line))\n# find line with \"Estimated genome size\" and get value\nfor line in stderr.splitlines():\nif \"Estimated genome size\" in line:\nself.estimated_genome_size = float(line.split()[-1])\nbreak\nelse:\nraise ValueError(\n\"Estimated genome size could not be parsed from mash sketch STDERR\"\n)\n</code></pre>"},{"location":"reference/#the-fastaauriclass-class","title":"The <code>FastaAuriclass</code> class","text":"<p>             Bases: <code>BasicAuriclass</code></p> Source code in <code>auriclass/classes.py</code> <pre><code>class FastaAuriclass(BasicAuriclass):\ndef sketch_fasta_query(self) -&gt; None:\n\"\"\"\n        Sketches the query fasta files using mash.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Raises\n        ------\n        ValueError\n            If no sequence records are found in the specified fasta file(s).\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - stdout: the STDOUT of the mash sketch command\n        - estimated_genome_size: the estimated genome size of the current test sample\n        The function uses the following attributes of the object:\n        - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch\n        - query_sketch_path: the path to the query sketch\n        - kmer_size: the kmer size to use for the sketch\n        - sketch_size: the size of the sketch to create\n        - read_paths: the paths to the fastq files to sketch\n        \"\"\"\ncommand = [\n\"mash\",\n\"sketch\",\n\"-o\",\nself.query_sketch_path,\n\"-k\",\nstr(self.kmer_size),\n\"-s\",\nstr(self.sketch_size),\n*self.read_paths,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash sketch\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif \"ERROR: Did not find fasta records in\" in output.stderr.decode(\"utf-8\"):\nraise ValueError(\nf\"Did not find sequence records in {self.read_paths}. Please check if these are valid fastq files\"\n)\n# Add stdout and stderr to object\nself.stdout = output.stdout.decode(\"utf-8\")\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash sketch\", line))\ndef parse_genome_size(self) -&gt; None:\n\"\"\"\n        Parse the size of the fasta input using pyfastx.\n        Parameters\n        ----------\n        self : object\n            The AuriClassAnalysis object.\n        Returns\n        -------\n        None\n        Notes\n        -----\n        This function sets the following attributes of the object:\n        - estimated_genome_size: the estimated genome size of the current test sample\n        The function uses the following attributes of the object:\n        - read_paths: the paths to the fasta files to parse\n        \"\"\"\ntotal_size = 0\nfor filepath in self.read_paths:\n# Reading a fasta file requires index building, so remove this afterwards\ntotal_size += pyfastx.Fasta(filepath, build_index=True).size\nPath(str(filepath) + \".fxi\").unlink(missing_ok=True)\nself.estimated_genome_size = total_size\ndef run(self) -&gt; None:\n# Sketch query genome using tempfile\nwith tempfile.TemporaryDirectory() as tmpdir:\nself.query_sketch_path = Path(tmpdir).joinpath(\"tmpfile.msh\")\nself.sketch_fasta_query()\n# Run mash screen\nself.run_mash_dist()\n# Check if genome size is within expected range\nself.parse_genome_size()\nself.check_genome_size()\n# Process results\nself.select_clade()\n# Check if all samples not above certain threshold indicating other species\nprobably_candida = self.check_non_candida()\nif probably_candida:\n# Check if clade is not \"outgroup\"\nprobably_cauris = self.check_for_outgroup()\nif probably_cauris:\nif self.no_qc == False:\n# Check if closest sample is above self.high_dist_threshold distance --&gt; new clade?\nself.check_high_dist()\n# Check error bounds and check number of samples within error bounds\nerror_bounds_text = self.get_error_bounds()\nself.process_error_bounds(error_bounds_text)\nself.compare_with_error_bounds()\nelse:\nself.clade = \"other Candida/CUG-Ser1 clade sp.\"\nelse:\nself.clade = \"not Candida auris\"\nself.qc_other_candida = \"SKIPPED\"\nself.qc_genome_size = \"SKIPPED\"\nself.qc_multiple_hits = \"SKIPPED\"\nself.qc_high_distance = \"SKIPPED\"\n# Save report\nself.save_report()\n</code></pre>"},{"location":"reference/#auriclass.classes.FastaAuriclass.parse_genome_size","title":"<code>parse_genome_size()</code>","text":"<p>Parse the size of the fasta input using pyfastx.</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.parse_genome_size--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.parse_genome_size--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.parse_genome_size--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - estimated_genome_size: the estimated genome size of the current test sample</p> <p>The function uses the following attributes of the object: - read_paths: the paths to the fasta files to parse</p> Source code in <code>auriclass/classes.py</code> <pre><code>def parse_genome_size(self) -&gt; None:\n\"\"\"\n    Parse the size of the fasta input using pyfastx.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - estimated_genome_size: the estimated genome size of the current test sample\n    The function uses the following attributes of the object:\n    - read_paths: the paths to the fasta files to parse\n    \"\"\"\ntotal_size = 0\nfor filepath in self.read_paths:\n# Reading a fasta file requires index building, so remove this afterwards\ntotal_size += pyfastx.Fasta(filepath, build_index=True).size\nPath(str(filepath) + \".fxi\").unlink(missing_ok=True)\nself.estimated_genome_size = total_size\n</code></pre>"},{"location":"reference/#auriclass.classes.FastaAuriclass.sketch_fasta_query","title":"<code>sketch_fasta_query()</code>","text":"<p>Sketches the query fasta files using mash.</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.sketch_fasta_query--parameters","title":"Parameters","text":"<p>self : object     The AuriClassAnalysis object.</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.sketch_fasta_query--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.sketch_fasta_query--raises","title":"Raises","text":"<p>ValueError     If no sequence records are found in the specified fasta file(s).</p>"},{"location":"reference/#auriclass.classes.FastaAuriclass.sketch_fasta_query--notes","title":"Notes","text":"<p>This function sets the following attributes of the object: - stdout: the STDOUT of the mash sketch command - estimated_genome_size: the estimated genome size of the current test sample</p> <p>The function uses the following attributes of the object: - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch - query_sketch_path: the path to the query sketch - kmer_size: the kmer size to use for the sketch - sketch_size: the size of the sketch to create - read_paths: the paths to the fastq files to sketch</p> Source code in <code>auriclass/classes.py</code> <pre><code>def sketch_fasta_query(self) -&gt; None:\n\"\"\"\n    Sketches the query fasta files using mash.\n    Parameters\n    ----------\n    self : object\n        The AuriClassAnalysis object.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    ValueError\n        If no sequence records are found in the specified fasta file(s).\n    Notes\n    -----\n    This function sets the following attributes of the object:\n    - stdout: the STDOUT of the mash sketch command\n    - estimated_genome_size: the estimated genome size of the current test sample\n    The function uses the following attributes of the object:\n    - minimal_kmer_coverage: the minimal kmer coverage to use for the sketch\n    - query_sketch_path: the path to the query sketch\n    - kmer_size: the kmer size to use for the sketch\n    - sketch_size: the size of the sketch to create\n    - read_paths: the paths to the fastq files to sketch\n    \"\"\"\ncommand = [\n\"mash\",\n\"sketch\",\n\"-o\",\nself.query_sketch_path,\n\"-k\",\nstr(self.kmer_size),\n\"-s\",\nstr(self.sketch_size),\n*self.read_paths,\n]\ncommand_list_of_str = [str(item) for item in command]\nlogging.info(add_tag(\"mash sketch\", \" \".join(command_list_of_str)))\noutput = subprocess.run(\ncommand_list_of_str,\nstdout=subprocess.PIPE,\nstderr=subprocess.PIPE,\n)\nif \"ERROR: Did not find fasta records in\" in output.stderr.decode(\"utf-8\"):\nraise ValueError(\nf\"Did not find sequence records in {self.read_paths}. Please check if these are valid fastq files\"\n)\n# Add stdout and stderr to object\nself.stdout = output.stdout.decode(\"utf-8\")\nstderr = output.stderr.decode(\"utf-8\")\nif stderr:\nfor line in stderr.splitlines():\nlogging.info(add_tag(\"mash sketch\", line))\n</code></pre>"},{"location":"reference/#general-scripts","title":"General scripts","text":""},{"location":"reference/#auriclass.general.add_tag","title":"<code>add_tag(tag, lines)</code>","text":"<p>Add a tag to a string or list of strings.</p>"},{"location":"reference/#auriclass.general.add_tag--parameters","title":"Parameters","text":"<p>tag : str     The tag to add. lines : str or list of str     The string or list of strings to add the tag to.</p>"},{"location":"reference/#auriclass.general.add_tag--returns","title":"Returns","text":"<p>str     The string with the tag added to each line.</p> Source code in <code>auriclass/general.py</code> <pre><code>def add_tag(tag: str, lines: str) -&gt; str:\n\"\"\"\n    Add a tag to a string or list of strings.\n    Parameters\n    ----------\n    tag : str\n        The tag to add.\n    lines : str or list of str\n        The string or list of strings to add the tag to.\n    Returns\n    -------\n    str\n        The string with the tag added to each line.\n    \"\"\"\nfull_tag = f\"[{tag}]\"\nif lines:\nreturn \"\\n\".join(\n[f\"{full_tag} {line}\" for line in lines.split(\"\\n\") if line != \"\"]\n)\nelse:\nreturn f\"{full_tag}\"\n</code></pre>"},{"location":"reference/#auriclass.general.check_dependencies","title":"<code>check_dependencies()</code>","text":"<p>Check if dependencies are installed.</p>"},{"location":"reference/#auriclass.general.check_dependencies--parameters","title":"Parameters","text":"<p>None</p>"},{"location":"reference/#auriclass.general.check_dependencies--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.general.check_dependencies--raises","title":"Raises","text":"<p>FileNotFoundError     If mash is not installed.</p> Source code in <code>auriclass/general.py</code> <pre><code>def check_dependencies() -&gt; None:\n\"\"\"\n    Check if dependencies are installed.\n    Parameters\n    ----------\n    None\n    Returns\n    -------\n    None\n    Raises\n    ------\n    FileNotFoundError\n        If mash is not installed.\n    \"\"\"\ntry:\nsubprocess.call(\n[\"mash\", \"-h\"],\nstdout=subprocess.DEVNULL,\nstderr=subprocess.DEVNULL,\n)\nexcept FileNotFoundError:\nraise FileNotFoundError(\"Mash is not installed\")\n</code></pre>"},{"location":"reference/#auriclass.general.check_number_within_range","title":"<code>check_number_within_range(minimum=0, maximum=1)</code>","text":"<p>Creates a function to check whether a numeric value is within a range, inclusive.</p> <p>The generated function can be used by the <code>type</code> parameter in argparse.ArgumentParser. See https://stackoverflow.com/a/53446178.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>the numeric value to check.</p> required <code>minimum</code> <code>float</code> <p>minimum of allowed range, inclusive.</p> <code>0</code> <code>maximum</code> <code>float</code> <p>maximum of allowed range, inclusive.</p> <code>1</code> <p>Returns:</p> Type Description <code>Union[Callable[[str], str], FileType]</code> <p>A function which takes a single argument and checks this against the range.</p> <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>if the value is outside the range.</p> <code>ValueError</code> <p>if the value cannot be converted to float.</p> Source code in <code>auriclass/general.py</code> <pre><code>def check_number_within_range(\nminimum: float = 0, maximum: float = 1\n) -&gt; Union[Callable[[str], str], argparse.FileType]:\n\"\"\"\n    Creates a function to check whether a numeric value is within a range, inclusive.\n    The generated function can be used by the `type` parameter in argparse.ArgumentParser.\n    See https://stackoverflow.com/a/53446178.\n    Args:\n        value: the numeric value to check.\n        minimum: minimum of allowed range, inclusive.\n        maximum: maximum of allowed range, inclusive.\n    Returns:\n        A function which takes a single argument and checks this against the range.\n    Raises:\n        argparse.ArgumentTypeError: if the value is outside the range.\n        ValueError: if the value cannot be converted to float.\n    \"\"\"\ndef generated_func_check_range(value: str) -&gt; str:\nvalue_f = float(value)\nif (value_f &lt; minimum) or (value_f &gt; maximum):\nraise argparse.ArgumentTypeError(\nf\"Supplied value {value} is not within expected range {minimum} to {maximum}.\"\n)\nreturn str(value)\nreturn generated_func_check_range\n</code></pre>"},{"location":"reference/#auriclass.general.confirm_input_type","title":"<code>confirm_input_type(list_of_file_paths, input_type)</code>","text":"<p>Confirms that input files are of the specified type.</p>"},{"location":"reference/#auriclass.general.confirm_input_type--parameters","title":"Parameters","text":"<p>list_of_file_paths : list of str     The list of filepaths to check. input_type : str     The input type to check.</p>"},{"location":"reference/#auriclass.general.confirm_input_type--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.general.confirm_input_type--raises","title":"Raises","text":"<p>None</p>"},{"location":"reference/#auriclass.general.confirm_input_type--notes","title":"Notes","text":"<p>This function does not raise any exceptions, but it does log a warning if any of the input files are not of the specified type. This is intended to run if the user specifies the input type with --fastq or --fasta.</p> Source code in <code>auriclass/general.py</code> <pre><code>def confirm_input_type(list_of_file_paths: List[str], input_type: str) -&gt; None:\n\"\"\"\n    Confirms that input files are of the specified type.\n    Parameters\n    ----------\n    list_of_file_paths : list of str\n        The list of filepaths to check.\n    input_type : str\n        The input type to check.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    None\n    Notes\n    -----\n    This function does not raise any exceptions, but it does log a warning if any of the input files are not of the specified type.\n    This is intended to run if the user specifies the input type with --fastq or --fasta.\n    \"\"\"\nfor file_path in list_of_file_paths:\nif input_type == \"fastq\":\nif not is_fastq(file_path):\nlogging.warning(\nf\"Input file {file_path} cannot be parsed as a fastq file, please check if --fastq is appropriate\"\n)\nelif input_type == \"fasta\":\nif not is_fasta(file_path):\nlogging.warning(\nf\"Input file {file_path} cannot be parsed as a fasta file, please check if --fasta is appropriate\"\n)\n</code></pre>"},{"location":"reference/#auriclass.general.guess_input_type","title":"<code>guess_input_type(list_of_file_paths)</code>","text":"<p>Guess the input type of a list of files.</p>"},{"location":"reference/#auriclass.general.guess_input_type--parameters","title":"Parameters","text":"<p>list_of_file_paths : list of str     The list of filepaths to check.</p>"},{"location":"reference/#auriclass.general.guess_input_type--returns","title":"Returns","text":"<p>str     The input type, either \"fastq\" or \"fasta\".</p>"},{"location":"reference/#auriclass.general.guess_input_type--raises","title":"Raises","text":"<p>ValueError     If any of the input files can be parsed as both fastq and fasta.</p> <pre><code>If any of the input files cannot be parsed as either fastq or fasta.\n\nIf the input files are a mix of fastq and fasta files.\n\nIf no input files were found.\n</code></pre> Source code in <code>auriclass/general.py</code> <pre><code>def guess_input_type(list_of_file_paths: List[str]) -&gt; str:\n\"\"\"\n    Guess the input type of a list of files.\n    Parameters\n    ----------\n    list_of_file_paths : list of str\n        The list of filepaths to check.\n    Returns\n    -------\n    str\n        The input type, either \"fastq\" or \"fasta\".\n    Raises\n    ------\n    ValueError\n        If any of the input files can be parsed as both fastq and fasta.\n        If any of the input files cannot be parsed as either fastq or fasta.\n        If the input files are a mix of fastq and fasta files.\n        If no input files were found.\n    \"\"\"\nfastq_count = 0\nfasta_count = 0\nfor file_path in list_of_file_paths:\nif is_fastq(file_path):\nif is_fasta(file_path):\nraise ValueError(\nf\"Input file {file_path} can be parsed as both fastq and fasta. Please specify --fastq or --fasta\"\n)\nelse:\nfastq_count += 1\nelif is_fasta(file_path):\nfasta_count += 1\nelse:\nraise ValueError(f\"Input file {file_path} is not a fastq or fasta file\")\nif fastq_count &gt; 0 and fasta_count &gt; 0:\nraise ValueError(f\"Input files are a mix of fastq and fasta files\")\nelif fastq_count &gt; 0:\nreturn \"fastq\"\nelif fasta_count &gt; 0:\nreturn \"fasta\"\nelse:\nraise ValueError(f\"No input files were found\")\n</code></pre>"},{"location":"reference/#auriclass.general.is_fasta","title":"<code>is_fasta(file)</code>","text":"<p>Check if a file is a fasta file.</p>"},{"location":"reference/#auriclass.general.is_fasta--parameters","title":"Parameters","text":"<p>filepath : str     The path to the file to check.</p>"},{"location":"reference/#auriclass.general.is_fasta--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.general.is_fasta--raises","title":"Raises","text":"<p>RuntimeError     If the file is not a fasta file.</p> Source code in <code>auriclass/general.py</code> <pre><code>def is_fasta(file: str) -&gt; bool:\n\"\"\"\n    Check if a file is a fasta file.\n    Parameters\n    ----------\n    filepath : str\n        The path to the file to check.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    RuntimeError\n        If the file is not a fasta file.\n    \"\"\"\ntry:\npyfastx.Fasta(file, build_index=False)\nreturn True\nexcept RuntimeError:\nreturn False\n</code></pre>"},{"location":"reference/#auriclass.general.is_fastq","title":"<code>is_fastq(file)</code>","text":"<p>Check if a file is a fastq file.</p>"},{"location":"reference/#auriclass.general.is_fastq--parameters","title":"Parameters","text":"<p>filepath : str     The path to the file to check.</p>"},{"location":"reference/#auriclass.general.is_fastq--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.general.is_fastq--raises","title":"Raises","text":"<p>RuntimeError     If the file is not a fastq file.</p> Source code in <code>auriclass/general.py</code> <pre><code>def is_fastq(file: str) -&gt; bool:\n\"\"\"\n    Check if a file is a fastq file.\n    Parameters\n    ----------\n    filepath : str\n        The path to the file to check.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    RuntimeError\n        If the file is not a fastq file.\n    \"\"\"\ntry:\npyfastx.Fastq(file, build_index=False)\nreturn True\nexcept RuntimeError:\nreturn False\n</code></pre>"},{"location":"reference/#auriclass.general.validate_argument_logic","title":"<code>validate_argument_logic(args)</code>","text":"<p>Check if arguments are valid, based on predefined logic.</p>"},{"location":"reference/#auriclass.general.validate_argument_logic--parameters","title":"Parameters","text":"<p>args : argparse.Namespace     The arguments to check.</p>"},{"location":"reference/#auriclass.general.validate_argument_logic--returns","title":"Returns","text":"<p>argparse.Namespace     The arguments, if they are valid. Modified if necessary.</p>"},{"location":"reference/#auriclass.general.validate_argument_logic--raises","title":"Raises","text":"<p>ValueError     If the arguments are not valid.</p> Source code in <code>auriclass/general.py</code> <pre><code>def validate_argument_logic(args: argparse.Namespace) -&gt; argparse.Namespace:\n\"\"\"\n    Check if arguments are valid, based on predefined logic.\n    Parameters\n    ----------\n    args : argparse.Namespace\n        The arguments to check.\n    Returns\n    -------\n    argparse.Namespace\n        The arguments, if they are valid. Modified if necessary.\n    Raises\n    ------\n    ValueError\n        If the arguments are not valid.\n    \"\"\"\n# Convert to float\nargs.expected_genome_size = [\nfloat(args.expected_genome_size[0]),\nfloat(args.expected_genome_size[1]),\n]\n# Check if specified genome size range is valid\nif args.expected_genome_size[0] &gt; args.expected_genome_size[1]:\nraise ValueError(\n\"Expected genome size range is invalid: lower bound is higher than upper bound\"\n)\nelif (args.expected_genome_size[0] &lt; 100) &amp; (args.expected_genome_size[1] &lt; 100):\nlogging.warning(\nf\"Expected genome size range boundaries {args.expected_genome_size} are below 100: treating these as Mbp instead of bp\"\n)\nargs.expected_genome_size = [\nargs.expected_genome_size[0] * 1_000_000,\nargs.expected_genome_size[1] * 1_000_000,\n]\nreturn args\n</code></pre>"},{"location":"reference/#auriclass.general.validate_input_files","title":"<code>validate_input_files(list_of_files)</code>","text":"<p>Check if files in a list exist.</p>"},{"location":"reference/#auriclass.general.validate_input_files--parameters","title":"Parameters","text":"<p>list_of_files : list of str     The list of filepaths to check.</p>"},{"location":"reference/#auriclass.general.validate_input_files--returns","title":"Returns","text":"<p>None</p>"},{"location":"reference/#auriclass.general.validate_input_files--raises","title":"Raises","text":"<p>FileNotFoundError     If any of the files do not exist.</p> Source code in <code>auriclass/general.py</code> <pre><code>def validate_input_files(list_of_files: List[str]) -&gt; None:\n\"\"\"\n    Check if files in a list exist.\n    Parameters\n    ----------\n    list_of_files : list of str\n        The list of filepaths to check.\n    Returns\n    -------\n    None\n    Raises\n    ------\n    FileNotFoundError\n        If any of the files do not exist.\n    \"\"\"\nfor filepath in list_of_files:\nif not Path(filepath).exists():\nraise FileNotFoundError(f\"Required input file {filepath} does not exist\")\n</code></pre>"},{"location":"reference_genomes/","title":"Reference genomes","text":"<p>Reference genomes for C. auris clades were selected from Suphavilai et al., Discovery of the sixth Candida auris clade in Singapore (medRxiv) and include two (nearly) completed genomes per clade, if freely available from NCBI. For Clade V only one (nearly) complete genome was available from NCBI. Related species were selected from figure 3 of Mu\u00f1oz et al., Genomic insights into multidrug-resistance, mating and virulence in Candida auris and related emerging species (NatComm). Representative genomes were downloaded from NCBI. The sketch was constructed using sketch size 50,000 and k-mer size 27.</p> <p>If you are missing new clades or have other reference genomes that would be good to include, please open an issue on GitHub.</p> <p>The following reference genomes are included in the default database:</p> filename clade refs/GCA_002759435.2_Candida_auris_CladeI.fna Clade I refs/GCA_002775015.1_Candida_auris_CladeIII.fna Clade III refs/GCA_003013715.2_Candida_auris_CladeII.fna Clade II refs/GCA_003014415.1_Candida_auris_CladeIV.fna Clade IV refs/GCA_008275145.1_Candida_auris_CladeIV.fna Clade IV refs/GCA_014217455.1_Candida_auris_CladeIII.fna Clade III refs/GCA_014673535.1_Candida_auris_CladeI.fna Clade I refs/GCA_016495665.1_Candida_auris_CladeII.fna Clade II refs/GCA_016809505.1_Candida_auris_CladeV.fna Clade V refs/GCA_032367535.1_Candida_auris_CladeVI.fna Clade VI refs/GCA_032715285.1_Candida_auris_CladeVI.fna Clade VI refs/GCF_000002545.3_Nakaseomyces_glabratus.fna outgroup refs/GCF_000003835.1_Clavispora_lusitaniae.fna outgroup refs/GCF_000006335.3_Candida_tropicalis.fna outgroup refs/GCF_000006445.2_Debaryomyces_hansenii.fna outgroup refs/GCF_000026945.1_Candida_dubliniensis.fna outgroup refs/GCF_000149425.1_Meyerozyma_guilliermondii.fna outgroup refs/GCF_000149685.1_Lodderomyces_elongisporus.fna outgroup refs/GCF_000182765.1_Candida_parapsilosis.fna outgroup refs/GCF_000182965.3_Candida_albicans.fna outgroup refs/GCF_000315875.1_Candida_orthopsilosis.fna outgroup refs/GCF_002926055.2_Candida_haemulonii.fna outgroup refs/GCF_003013735.1_Candida_pseudohaemulonii.fna outgroup refs/GCF_003054445.1_Pichia_kudriavzevii.fna outgroup"},{"location":"running_analysis/","title":"Running an analysis","text":"<p>Running AuriClass on only the forward reads gives the best results, as the reverse reads are usually more noisy:</p> <pre><code>auriclass Candida_auris_R1.fq.gz\n</code></pre> <p>But it can also be run on an arbitrary number of fastq files of the same sample:</p> <pre><code>auriclass Candida_auris_R1.fq.gz Candida_auris_R2.fq.gz Candida_auris_unpaired.fq.gz\n</code></pre> <p>or with a fasta file:</p> <pre><code>auriclass Candida_auris.fasta.gz\n</code></pre> <p>Note</p> <p>All input files are treated as a single sample, so running <code>auriclass input_genomes/*.fasta</code> will try to do a single clade prediction for all fasta files in <code>input_genomes</code>. To run AuriClass on multiple samples, check out Running multiple samples in parallel</p> <p>A standard analysis creates two files: - <code>report.tsv</code> which contains the clade prediction, closest reference sample and QC checks. The report contains the default \"isolate\" as sample name. - <code>report.YYYY-mm-dd_HH-MM-SS.log</code> which contains messages written to STDERR with additional data.</p>"},{"location":"running_analysis/#specifying-output","title":"Specifying output","text":"<p>This will create <code>report_Candida_auris.tsv</code> and <code>report_Candida_auris.log</code>. The report will contain the sample name \"Candida_auris\".</p> <pre><code>auriclass --name Candida_auris -o report_Candida_auris.tsv Candida_auris_R1.fq.gz\n</code></pre>"},{"location":"running_analysis/#forcing-full-analysis","title":"Forcing full analysis","text":"<p>This forces AuriClass to perform the full analysis on a sample, even if the species quality check fails.</p> <pre><code>auriclass --non_candida_threshold 1 Candida_auris_R1.fq.gz\n</code></pre> <p>Warning</p> <p>This will cause some QC checks to always pass, so use with caution.</p>"},{"location":"running_analysis/#running-multiple-samples-in-parallel","title":"Running multiple samples in parallel","text":"<p>AuriClass currently does not support multithreaded analysis. For both Fastq and Fasta input, multi-threading <code>mash</code> commands where possible makes minimal difference. Additionally, peak memory usage is typically 100-200 Mb RAM according to <code>/usr/bin/time -v</code>. Therefore, the best option if you have to analyse a lot of files is to run multiple AuriClass analyses concurrently. </p> <p>Two good options are either:</p> <ul> <li>workflow managers such as Snakemake, Nextflow, etc. or</li> <li>GNU <code>parallel</code>.</li> </ul> <p>An example how to run AuriClass using <code>parallel</code> on a set of assemblies in the directory <code>fasta_input</code>:</p> <pre><code>parallel auriclass --fasta -n {/.} -o report.{/.}.tsv {} ::: fasta_input/*\n</code></pre>"}]}